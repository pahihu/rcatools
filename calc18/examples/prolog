..
..  PROLOG
..
DMA=#00
INT=#01
SP=#02
PC=#03
SCALL=#04
SRET=#05
ARGPTR=#06
AC=#07
RETVAL=#07
AUX=#08
SUB=#09
MA=#0A
MQ=#0A
TMP=#0B
REG2=#0D
REG1=#0E
FP=#0F
SSEG=#7FFF
INIT1=#83F3
INIT2=#83F6
HOMDSK=#82BA   ..HOME DISKS
LOADER=#8400   ..LOADER $L
EWRITE=#8500   ..WRITE SECTOR
EREAD=#8502    ..READ SECTOR
..
 ORG#0000

 DIS,#33                        ..X=P=3
 OUT 1,#01                      ..TWO-LEVEL I/O
 LDI A.1(SSEG) ;PHI SP          ..SP=SSEG
 LDI A.0(SSEG) ;PLO SP
 SEX SP                         ..X=SP
 LDI A.1(UMULT) ;PHI SUB        ..SUB.1=UMULT.1
 LDI A.1(CALL) ;PHI SCALL       ..SCALL
 LDI A.0(CALL) ;PLO SCALL
 LDI A.1(RET) ;PHI SRET         ..SRET
 LDI A.0(RET) ;PLO SRET
 SEP SCALL,A(Lmain)             ..main()
 SEP SCALL,A(Lexit)             ..exit()
..
..  STANDARD CALL ROUTINE
..
RCALL: SEP PC
CALL:  SEX SP
 GHI ARGPTR ;STXD        ..PUSH ARGPTR
 GLO ARGPTR ;STXD
 GHI PC ;PHI ARGPTR      ..ARGPTR=PC
 GLO PC ;PLO ARGPTR
 LDA ARGPTR ;PHI PC      ..PC=*ARGPTR
 LDA ARGPTR ;PLO PC
 BR RCALL                ..BRANCH TO ENTRY
..
..  STANDARD RETURN ROUTINE
..
RRET: SEP PC
RET:
 GHI ARGPTR ;PHI PC      ..PC=ARGPTR
 GLO ARGPTR ;PLO PC
 SEX SP                  ..X=SP
 INC SP
 LDXA ;PLO ARGPTR        ..POP ARGPTR
 LDX  ;PHI ARGPTR
 GHI RETVAL
 BR RRET
 ..
 ..  RUNTIME BRANCH TABLE
 ..
UMULT:  LBR RTUMULT
UDIV:   LBR RTUDIV
SWITCH: LBR RTSWITCH
PAR8:   LBR RTPAR8
AUT8:   LBR RTAUT8
SUBENT: LBR RTSUBENT
SUBRET: LBR RTSUBRET
IDX:    LBR RTIDX
ASGN:   LBR RTASGN
NCALL:  LBR RTNCALL
..
..  UNSIGNED MULT AC BY AUX
..
RTUMULT:
 IRX ;IRX                .. SP->AUX.1
 LDI #00 ;PHI MQ ;PLO MQ .. MQ=0
 GHI AC ;BZ UMULT8       .. AC.0==0? GOTO UMULT8
 LDI #10 ;PLO TMP        .. TMP.0=#10
M1:
 GLO MQ ;SHL  ;PLO MQ    .. MQ = MQ << 1
 GHI MQ ;SHLC ;PHI MQ
 GLO AC ;SHL  ;PLO AC    .. IF MSB(AC) == 0 GOTO NOADD
 GHI AC ;SHLC ;PHI AC
 BNF NOADD
 DEC SP                    .. --SP
 GLO MQ       ;ADD ;PLO MQ .. MQ += *SP
 GHI MQ ;IRX  ;ADC ;PHI MQ
NOADD:
 DEC TMP                 .. IF --TMP != 0 GOTO M1
 GLO TMP ;BNZ M1
 BR MACMQ
UMULT8:
 LDI #08 ;PLO TMP        .. TMP.0=#10
M18:
 GLO MQ ;SHL  ;PLO MQ    .. MQ = MQ << 1
 GHI MQ ;SHLC ;PHI MQ
 GLO AC ;SHL  ;PLO AC    .. IF MSB(AC.0) = 0 GOTO NOADD
 BNF NOADD8
 DEC SP                  .. --SP
 GLO MQ       ;ADD ;PLO MQ .. MQ += *SP
 GHI MQ ;IRX  ;ADC ;PHI MQ
NOADD8:
 DEC TMP                 .. IF --TMP != 0 GOTO M18
 GLO TMP ;BNZ M18
MACMQ:
 GLO MQ ;PLO AC          .. AC = MQ
 GHI MQ ;PHI AC
 LBR RRET
 ..
 ..  UNSIGNED DIVIDE AC BY AUX
 ..
 .. R - REMAINDER, Q - QUOTIENT, X - DIVIDEND, Y - DIVISOR
 .. X - AC, Y - *SP, Y0 - AUX, R - MQ
 .. USES ARGPTR
 ..
RTUDIV:

 .. r = x; q = 0 (x dividend, y divisor)
 .. X - AC, Y - *SP, Y0 - AUX, R - MQ, TMP -
SDM:
 GLO AC ;PLO MQ                 ..R=X
 GHI AC ;PHI MQ
 IRX ;LDXA ;PLO AUX             ..Y0=Y
      LDX ;PHI AUX              .. SP->Y.1
 DEC SP                         .. SP->Y.0
 GLO AC      ;SM ;PLO TMP       ..IF X>=Y
 GHI AC ;IRX ;SMB               .. SP->Y.1
 BNF COMPQ0
 PHI AC ;GLO TMP ;PLO AC        ..X=X-Y
DBLD:                           ..WHILE
 DEC SP                         .. SP->Y.0
 GLO AC      ;SM ;PLO TMP       ..X>=Y
 GHI AC ;IRX ;SMB               .. SP->Y.1
 BNF COMPQ0
 PHI AC ;GLO TMP ;PLO AC        ..X=X-Y
 DEC SP                         .. SP->Y.0
 LDX ;SHL  ;STR SP              ..Y=Y+Y
 IRX ;LDX ;SHLC ;STR SP         .. SP->Y.1
 BR DBLD
COMPQ0:
 .. Q IS AC
 LDI #00 ;PLO AC ;PHI AC        ..Q = 0
 DEC SP                         .. SP->Y.0
COMPQ:
 GLO MQ ;SM ;PLO TMP            ..IF (R >= Y)
 GHI MQ ;IRX ;SMB               .. SP->Y.1
 BNF CHK0
 PHI MQ ;GLO TMP ;PLO MQ        ..R = R - Y
 INC AC                         ..Q = Q + 1
CHK0:
 DEC SP                         .. SP->Y.0
 GLO AUX ;XOR ;IRX ;LBNZ YNEY0  ..IF Y == Y0 BREAK, SP->Y.1
 GHI AUX ;XOR ;LBZ SDMEND
YNEY0:
 GLO AC ;SHL ;PLO AC            ..Q = Q + Q
 GHI AC ;SHLC ;PHI AC
 LDX ;SHR ;STR SP               ..Y = HALF(Y)
 DEC SP ;LDX ;SHRC ;STR SP      .. SP->Y.0
 BR COMPQ
SDMEND:
 ...
 LBR RRET
..
..  CALL ROUTINE IN AC
..
RTNCALL:
 GHI ARGPTR ;STXD        ..PUSH ARGPTR
 GLO ARGPTR ;STXD
 GHI PC ;PHI ARGPTR      ..ARGPTR=PC
 GLO PC ;PLO ARGPTR
 GLO AC ;SHL ;PLO PC     ..PC=2*AC
 GHI AC ;SHLC ;PHI PC
 LBR RRET                ..BRANCH TO ENTRY
 ..
 ..  SWITCH
 ..  AC = VAL TO JUMP ON, SWTAB ADDR ON STACK
 ..
 ..  LDI A.0(SWITCH) ;PLO SUB ;SEP SUB
 ..  DB #MAXCASE
 ..  DW ADDR(LEND)
 ..
RTSWITCH:
 LDA PC ;STR SP ;GLO AC ;SM      ..CHK MAXCASE
 LBDF LEND
 GLO AC ;SHL ;IRX ;ADD ;PLO MA   ..CALC OFFS, ADD TO SWTAB
 LDI #00 ;IRX ;ADC ;PHI MA
 LDA MA ;PHI PC         ..GET ADDR
 LDN MA ;PLO PC
 LBR RRET               ..JUMP TO CASE
LEND:
 LDA PC ;PHI AUX        ..JUMP TO LEND
 LDN PC ;PLO PC
 GHI AUX ;PHI PC
 LBR RRET
 ..
 ..  SUB ENTER
 ..
RTSUBENT:
 GHI FP ;STXD
 GLO FP ;STXD
 GLO SP ;PLO FP
 GHI SP ;PHI FP
 SEX PC
 GLO SP ;SM ;PLO SP
 LBDF RETADR
 GHI SP ;SMBI #00 ;PHI SP
 LBR RETADR
 ..
 ..  SUB RETURN
 ..
RTSUBRET:
 GLO FP ;PLO SP      ..SP=FP
 GHI FP ;PHI SP
 IRX ;LDXA ;PLO FP   ..POP FP
 LDX ;PHI FP
 LBR RET             ..STD RETURN
 ..
 ..  IDX LOAD ARRAY ADDRESS INTO MA
 ..
RTIDX:
 GLO AC ;IRX ;ADD ;PLO MA  ..MA=AC+*SP++
 GHI AC ;IRX ;ADC ;PHI MA
 GLO MA ;SHL ;PLO MA       ..MA=MA<<1
 GHI MA ;SHLC ;PHI MA
 LBR RRET
 ..
 ..  ASSIGN AC TO VAR ADDR ON STACK
 ..
RTASGN:
 IRX ;LDXA ;PLO MA         ..POP MA
 LDX ;PHI MA
 GLO AC ;STR MA ;INC MA    ..STR MA,AC
 GHI AC ;STR MA
 LBR RRET
 ..
 ..  PAR8 LOAD PARAMETER ADDRESS
 ..
RTPAR8:
 SEX PC
 GLO FP ;ADD ;PLO MA
 GHI FP ;ADCI #00 ;PHI MA
 LBR RETADR
 ..
 ..  AUT8 LOAD AUTO ADDRESS
 ..
RTAUT8:
 SEX PC
 GLO FP ;SM ;PLO MA
 GHI FP ;SMBI #00 ;PHI MA
RETADR:
 IRX ;SEX SP
 LBR RRET
 .. 
 ..  putc(c)
 ..
 ORG*+(* AND 1)
Lputc:
 GLO SP ;ADI #03 ;PLO MA        ..MA=ADDR(c)
 GHI SP ;ADCI #00 ;PHI MA
 LDN MA ;STR SP                 ..LOAD C.0
 OUT 2  ;DEC SP                 ..EMIT
 SEP SRET
 ..
 ..  getc()
 ..
 ORG*+(* AND 1)
Lgetc:
 INP 2  ;PLO AC                 ..AC.0=KEY
 LDI #00 ;PHI AC
 SEP SRET
 ..
 ..  exit()
 ..
 ORG*+(* AND 1)
Lexit:
 IDL     ..STOP
DIE:
 LBR DIE,#DEAD
 ..
 ..  char(s,x)
 ..
Lchar:
 GLO SP ;ADI #03 ;PLO MA         ..MA=ADDR(S)
 GHI SP ;ADCI #00 ;PHI MA
 LDA MA ;SHL  ;PLO AC            ..AC=2*S
 LDA MA ;SHLC ;PHI AC
 LDA MA ;STR SP ;GLO AC ;ADD ;PLO AUX  ..AUX.0=AC.0+X.0
 LDN MA ;STR SP ;GHI AC ;ADC ;PHI MA   ..MA.1=AC.1+AUX.1
 GLO AUX ;PLO MA                 ..MA.0=AUX.0
 LDN MA ;PLO AC                  ..AC=*MA
 LDI #00 ;PHI AC
 SEP SRET
 ..
 ..  lchar(s,x,c)
 ..
Llchar:
 GLO SP ;ADI #03 ;PLO MA         ..MA=ADDR(S)
 GHI SP ;ADCI #00 ;PHI MA
 LDA MA ;SHL  ;PLO AC            ..AC=2*S
 LDA MA ;SHLC ;PHI AC
 LDA MA ;STR SP ;GLO AC ;ADD ;PLO AUX  ..AUX=AC+X
 LDA MA ;STR SP ;GHI AC ;ADC ;PHI AUX
 LDA MA ;PLO AC                  ..AC.0=C.0
 STR AUX                         ..*AUX=AC.0
 LDN MA ;PHI AC                  ..AC.1=C.1
 SEP SRET
 ..
 ..  (st,c)=eread(dcb)
 ..  (st,0)=ewrite(dcb,c)
 ..
Leread:
 LDI #00 ;LSZ
Lewrite:
 LDI #01 ;PLO AC
 GHI FP ;STXD                   ..SAVE FP (RF)
 GLO FP ;STXD
 GLO SP ;ADI #05 ;PLO MA        ..MA->ARG1
 GHI SP ;ADCI #00 ;PHI MA
 LDA MA ;SHL  ;PLO RC           ..RC=*MA
 LDA MA ;SHLC ;PHI RC
 GLO AC ;LBZ MREAD              ..READ?
 LDN MA ;PHI RF                 ..RF=C
 SEP SCALL,A(EWRITE)            ..CALL EWRITE
 LDI #00 ;PLO RF                ..RF.0=0
 LBR MDONE
MREAD:
 SEP SCALL,A(EREAD)             ..CALL EREAD
MDONE:
 LDI #00 ;SHLC ;PHI AC          ..AC=(STATUS,RF.0)
 GLO RF ;PLO AC
 IRX ;LDXA ;PLO FP              ..RESTORE FP
 LDX ;PHI FP
 SEP SRET
 ..
 ..  homdsk()
 ..
Lhomdsk:
 LDI A.0(M0) ;PLO R0
 LDI A.1(M0) ;PHI R0
 SEX R0 ;SEP R0                 ..SWITCH TO R0
M0:
 LDI A.0(XHOMDSK) ;PLO PC       ..PC=SRET
 LDI A.1(XHOMDSK) ;PHI PC
 LBR HOMDSK                     ..JUMP TO HOMDSK
XHOMDSK:
 SEP SRET
 ..
 ..  PROGRAM
 ..
 .. vim: set ts=3 sw=3 et:
