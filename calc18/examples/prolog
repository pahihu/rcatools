..
..  PROLOG
..
DMA=#00
INT=#01
INTSP=#02
PC=#03
SCALL=#04
SRET=#05
ARGPTR=#06
SP=#07
AC=#08
RETVAL=#08
AUX=#09
SUB=#0A
MA=#0B
MQ=#0B
FP=#0F
SSEG=#7FFF
..
 ORG#0000

 DIS,#33                        ..X=P=3
 OUT 1,#01                      ..TWO-LEVEL I/O
 LDI A.1(SSEG) ;PHI SP          ..SP=SSEG
 LDI A.0(SSEG) ;PLO SP
 SEX SP                         ..X=SP
 LDI A.1(UMULT) ;PHI SUB        ..SUB.1=UMULT.1
 LDI A.1(CALL) ;PHI SCALL       ..SCALL
 LDI A.0(CALL) ;PLO SCALL
 LDI A.1(RET) ;PHI SRET         ..SRET
 LDI A.0(RET) ;PLO SRET
 SEP SCALL,A(Lmain)             ..main()
 SEP SCALL,A(Lexit)             ..exit()
..
..  STANDARD CALL ROUTINE
..
RCALL: SEP PC
CALL:
 GHI ARGPTR ;STXD        ..PUSH ARGPTR
 GLO ARGPTR ;STXD
 GHI PC ;PHI ARGPTR      ..ARGPTR=PC
 GLO PC ;PLO ARGPTR
 LDA ARGPTR ;PHI PC      ..PC=*ARGPTR
 LDA ARGPTR ;PLO PC
 BR RCALL                ..BRANCH TO ENTRY
..
..  STANDARD RETURN ROUTINE
..
RRET: SEP PC
RET:
 GHI ARGPTR ;PHI PC      ..PC=ARGPTR
 GLO ARGPTR ;PLO PC
 SEX SP                  ..X=SP
 INC SP
 LDXA ;PLO ARGPTR        ..POP ARGPTR
 LDX  ;PHI ARGPTR
 GHI RETVAL
 BR RRET
..
..  UNSIGNED MULT AC BY AUX
..
RUMULT:
 SEP PC
UMULT:
 IRX ;IRX
 GHI AC ;BZ UMULT8
 LDI #00 ;PHI MQ ;PLO MQ .. MQ=#0000
 LDI #10 ;PLO AUX        .. AUX.0=#10
M1:
 GLO AC ;SHR             .. IF AC.0 & 1 = 0 GOTO DIV2
 BNF DIV2
 DEC SP                    .. --SP
 GLO MQ       ;ADD ;PLO MQ .. MQ += *SP
 GHI MQ ;IRX  ;ADC ;PHI MQ
DIV2:
 GHI MQ ;SHR  ;PHI MQ    .. (MQ,AC) >> 1
 GLO MQ ;SHRC ;PLO MQ
 GHI AC ;SHRC ;PHI AC
 GLO AC ;SHRC ;PLO AC
 DEC AUX                 .. IF --AUX != 0 GOTO LOOP
 GLO AUX ;BNZ M1
 BR RUMULT               .. RESULT IS HIGH/LOW OF PROD?
UMULT8:
 PLO MQ                  .. MQ.0=#00
 LDI #08 ;PLO AUX        .. AUX.0=#10
M18:
 GLO AC ;SHR             .. IF AC.0 & 1 = 0 GOTO DIV2
 BNF DIV28
 DEC SP                    .. --SP
 GHI AC       ;ADD ;PHI AC .. (MQ.0,AC.1) += *SP
 GLO MQ ;IRX  ;ADC ;PLO MQ
DIV28:
 GLO MQ ;SHR  ;PLO MQ    .. (MQ.0,AC) >> 1
 GHI AC ;SHRC ;PHI AC
 GLO AC ;SHRC ;PLO AC
 DEC AUX                 .. IF --AUX != 0 GOTO LOOP
 GLO AUX ;BNZ M18
 BR RUMULT               .. RESULT IS HIGH/LOW OF PROD?
..
..  UNSIGNED DIVIDE AC BY AUX
..
RUDIV:
 SEP PC
UDIV:
 IRX ;LDXA ;PLO MQ       .. MQ=AUX.0, SP->AUX.1
 LDX ;BNZ PAUX           .. AUX.1#0? CONTINUE
 GLO MQ ;SHL ;BNF UDIV8  .. LO<128? GOTO UDIV8
PAUX:
 DEC SP
 GLO AC ;SM              .. AC<AUX? GOTO LT1
 GHI AC ;IRX ;SMB        .. SP->AUX.1
 BNF LT1
 LDI #00 ;PHI MQ ;PLO MQ .. MQ=#0000
 LDI #10 ;PLO AUX        .. AUX.0=#10
M2:
 GLO AC ;SHL  ;PLO AC    .. (MQ,AC) << 1
 GHI AC ;SHLC ;PHI AC
 GLO MQ ;SHLC ;PLO MQ
 GHI MQ ;SHLC ;PHI MQ
 DEC SP
 GLO MQ      ;SM  ;PHI AUX .. IF MQ - *SP < 0 GOTO NEG
 GHI MQ ;IRX ;SMB
 BNF NEG
 PHI MQ ;GHI AUX ;PLO MQ .. MQ = MQ - *SP
 INC AC                  .. AC=AC+1
NEG:
 DEC AUX
 GLO AUX ;BNZ M2
 BR RUDIV
LT1:
 GLO AC; PLO MQ          .. MQ=AC (REMAINDER)
 GHI AC; PHI MQ
 LDI #00 ;PLO AC ;PHI AC .. AC=0
 BR RUDIV
UDIV8:
 SHR ;STR SP             .. *SP=AUX.0

 GLO AC ;SM              .. AC<AUX? GOTO LT1
 GHI AC ;SMBI #00        .. SP->AUX.1
 BNF LT1

 LDI #00 ;PHI MQ ;PLO MQ .. MQ=#00
 LDI #10 ;PLO AUX        .. AUX.0=#10
M28:
 GLO AC ;SHL  ;PLO AC
 GHI AC ;SHLC ;PHI AC    .. (MQ.0,AC) << 1
 GLO MQ ;SHLC ;PLO MQ
 SM ;BNF NEG8            .. IF MQ - *SP < 0 GOTO NEG8
 PLO MQ                  .. MQ = MQ - *SP
 INC AC                  .. AC = AC + 1
NEG8:
 DEC AUX
 GLO AUX ;BNZ M28
 BR RUDIV
 ..
 ..  SWITCH
 ..  AC = VAL TO JUMP ON, SWTAB ADDR ON STACK
 ..
SWITCH:
 ..  CALC OFFS, ADD TO SWTAB
 GLO AC ;SHL ;ADD ;PLO MA
 LDI #00 ;IRX ;ADC ;PHI MA
 ..  GET ADDR
 LDA MA ;PHI PC
 LDN MA ;PLO PC
 ..  JUMP
 SEP PC
 ..
 ..  putc(c)
 ..
 ORG*+(* AND 1)
Lputc:
 GLO SP ;ADI #03 ;PLO MA        ..MA=ADDR(c)
 GHI SP ;ADCI #00 ;PHI MA
 LDN MA ;STR SP                 ..LOAD C.0
 OUT 2  ;DEC SP                 ..EMIT
 SEP SRET
 ..
 ..  getc()
 ..
 ORG*+(* AND 1)
Lgetc:
 INP 2  ;PLO AC                 ..AC.0=KEY
 LDI #00 ;PHI AC
 SEP SRET
..
..  PROGRAM
..
